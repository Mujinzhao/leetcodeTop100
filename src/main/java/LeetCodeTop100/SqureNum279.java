package LeetCodeTop100;

/**
 * @ClassName SqureNum279
 * @Description TODO
 * @Author zhangxinkun
 * @Date 2019/11/7  10:08 PM
 * @Version 1.0
 */

/**
 * 给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, ...）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。
 *
 * 示例 1:
 *
 * 输入: n = 12
 * 输出: 3
 * 解释: 12 = 4 + 4 + 4.
 * 示例 2:
 *
 * 输入: n = 13
 * 输出: 2
 * 解释: 13 = 4 + 9.
 *
 * 解析：非常经典的一道动态规划的题目，这一题目首先直观能想到的方法肯定是直接dfs 搜索，那么我们把真个搜索的路径用图纸画下来，就会
 * 发现对于每个给定的n 我们最终都是从 一个数 然后加上一个完全平方数过来的，（每一步都只能选平方数，当然如此）；
 * 所以我们就会发现有大量的重复计算，例如：对于12这个数字，我们只考虑最后一步搜索，11 加上 1（完全平方数）得到12；
 * 或者 8 加上 4（完全平方数）得到；3 + 9（完全平方数）得到12；那么如果我们能从1开始每一个数字对应的结果存下来，那问题就迎刃而解了；
 * 不难写出DP 公式  dp[n] = min(dp[n],dp[n-j*j]+1);
 *
 *
 * 这里写一下这个题目的心得：虽然这个题目比较简单，但是如果不熟悉动态规划的思想，其实还是比较难写出这个公式的；
 * 这里有两点需要注意：1、动态规划总是按照经验取找  dp[n] 和 dp[n-1]之间的关系，实际上这不是一个通用的思路，应为并不是
 * 每一个答案都可以根据紧挨着的上一个结果得出，比如这题，以后需要注意。
 * 2、动态规划适合  先把直观暴力的解法 用图画出来，然后去找找这个过程中有没有重复计算，重复计算的点找到了，其实公式也就差不多了。
 */
public class SqureNum279 {
    public int numSquares(int n) {
        int[] dp = new int[n+1];
        for(int i=1;i<=n;i++){
            dp[i] = i;
        }
        if(n == 1 ){
            return 1;
        }
        dp[0] = 0;
        for(int i=4;i<=n;i++){
            for(int j=1;j*j<=i;j++){
                dp[i] = Math.min(dp[i],dp[i-j*j]+1);
            }
        }
        return dp[n];
    }
}
